#include<stdio.h>
#include<iomanip>
#include<iostream>
#include<set>
#include<map>
#include<fstream>
#include<deque>
#include<queue>
#include<stdlib.h>
#include<vector>
#include<algorithm>
#include<string.h>
#include<math.h>
#include <sstream>

using namespace std;

typedef std::set<int> set_int ;
typedef std::queue<int> q_int;
typedef std::queue<double> q_double;
typedef std::set<set_int> set_set_int;
typedef std::map<set_int, int> mapfromSet;
/*Structure with four member field*/
typedef std::map<int,int>maploc;

struct Rows
{
    set_set_int Partition;
    mapfromSet tnodeAttach;
    double cost;
    set_set_int edgeset;
    maploc locmap;
};
      
    

  typedef   std::deque<Rows> tbl;
    std::deque<tbl>dbase,dbase1,tdb;
    set_int Target;q_int ElSeq;
     deque<q_int> posdb;
    double  Tx,Val=1.0/4;
    double Dist[100][10];
   
/*This Function will merge two Partition*/
deque<set_int> mPar(deque<set_int> z,deque<set_int> z1)
{
    bool flag=false;
    
    
            for(std::deque<set_int>::iterator j=z1.begin();j!=z1.end();j++)    
            {

                z.push_back(*j);

            }
   //pQueue(z);
    //cout<<endl;
   bool flag1;
    
  while(true)    {
        flag1=false;
        bool flag2=false;
        std::deque<set_int>::iterator jj;
    for(std::deque<set_int>::iterator i=z.begin();i<z.end();i++)
    {
       if(flag2) i=z.begin();
        set_int t=*i;
             flag2=false;
        for(set_int::iterator mm=t.begin();mm!=t.end();mm++)
        {
            flag=false;
            deque<set_int>::iterator t2,ti=i;
            ++ti;
            //if(z.size()>1)
            for(;ti<z.end();ti++)
            {
            set_int t1=*ti;
                for(set_int::iterator m=t1.begin();m!=t1.end();m++)
                {
                    if(*mm==*m)
                    {
                      flag=true;
                      for(set_int::iterator k=t1.begin();k!=t1.end();k++)
                      {
                          t.insert(*k);    
                      }
                      z.erase(i);
                      //pQueue(z);
                      z.push_front(t);
                     // z.push_back(t);
                      //pQueue(z);
                        z.erase(ti);
                        //pQueue(z);
                      break;  
                    }
             }
            if(flag)break;
            }
            if(flag)
            {
                
                flag1=true;
                flag2=true;
                 
                break;
            }
        }
       
    }
        if(!flag1) break;    }
    //cout<<"value"<<endl;    
   //pQueue(z);
   //cout<<endl; 
    return z;  
    
}

void pTnode(tbl Table)
{
    int i;
    double c=0;
    for(i=0;i<Table.size();i++)
        {
        cout<<setw(5);
             for (set_set_int::iterator it=Table[i].Partition.begin();it!=Table[i].Partition.end();it++)
                {
                    set_int T=*it;
                    cout<<"{";
                    for(set_int::iterator t=T.begin();t!=T.end();t++)
                    {
                        cout<<*t<<" ";
                    }
                    printf("} ");
                }
        cout<<"     ";
                for (std::map<int,int>::iterator mit=Table[i].locmap.begin();mit!=Table[i].locmap.end();++mit)
                {
                      
                       cout<<""<<mit->second<<"  ";
                 }
                
        cout<<Table[i].cost;
       if(Table[i].Partition.size()==1)c+=Table[i].cost;
                printf("\n");
        }
        printf("\n");
        cout<<"total cost="<<c;
  }

int findMnode(deque<tbl> db,set_int a)
{
    int tContr=0,flag,M;
   for (deque<tbl>::iterator it=db.begin();it!=db.end();++it)
    {
        tbl Table=*it;
        flag=0;
        tContr++;
        set_int allNode;
        for(int i=0;i<Table.size();i++)
        { 
            for (set_set_int::iterator mit=Table[i].Partition.begin();mit!=Table[i].Partition.end();++mit)
            {
               set_int m=*mit; 
                for(set_int::iterator sit=m.begin();sit!=m.end();++sit)
                {
                    allNode.insert(*sit);
                    
                }
             }
        }
        if(allNode==a)
        {
            M=tContr;
            break;
        }
   }
    return M;
}
bool Dcheck(tbl &temp,Rows obj)
{   
    bool flag=true,flag1;
    for(int i=0;i<temp.size();i++)
    {
        flag1=false;
        if(temp[i].Partition.size()==obj.Partition.size())
        {
            for(set_set_int::iterator it=temp[i].Partition.begin(),oit=obj.Partition.begin();it!=temp[i].Partition.end();it++,oit++)
            {
                set_int p=*it,q=*oit;
                if((*it).size()==(*oit).size())
                {
                    for(set_int::iterator sit=p.begin(),soit=q.begin();sit!=p.end();sit++,soit++)
                    {
                        if(*sit!=*soit)
                        {
                            flag1=true;
                            
                            break;
                        }
                        if(temp[i].locmap[*sit]!=obj.locmap[*soit])
                        {
                            flag1=true;
                            //temp[i].cost=temp[i].cost+obj.cost;
                            break;
                        }
                    }
                 
                }
                else
                {
                    flag1=true;
                    break;
                }
            }
          
        }
        else flag1=true;
        
        if(!flag1) 
        {
            flag=false;
            temp[i].cost=temp[i].cost+obj.cost;
            break;
        }
    }
   //if(!flag)temp[i].cost=temp[i].cost+obj.cost;
    return flag;
}
bool BadSt(Rows &obj,int es)
{
    bool flag=false;
    Rows ob;
    for(set_set_int::iterator it=obj.Partition.begin();it!=obj.Partition.end();it++)
    {
        set_int ss=*it;
        for(set_int::iterator sit=(*it).begin();sit!=(*it).end();sit++)
        {
            if(*sit==es)
            {
                if((*it).size()<2) 
                {
                    flag=true;
                    break;
                }
                ss.erase(es);
            }
            
            
        }
        if(ss.size()>0)
        {
            ob.Partition.insert(ss);
            for(set_set_int::iterator it1=ob.Partition.begin();it1!=ob.Partition.end();it1++)
            {
                set_int tt=*it1;
                for(set_int::iterator tt1=tt.begin();tt1!=tt.end();tt1++)
                {
                    ob.locmap[*tt1]=obj.locmap[*tt1];
                }
            }
        }
        if(flag==true)break;
    }
    ob.cost=obj.cost;
    
    obj=ob;
    return flag;
}
/*This Function will merge two Table Partition*/
              
tbl mTable(tbl Table1,tbl Table2,int com)
    {
       tbl temp;
       int x=1;
       for(int i=0;i<Table1.size();++i)
        {
           //cout<<Table1.size()<<" ";
           for(int j=0;j<Table2.size();j++)
             { 
              // cout<<x<<" ";x++;
                       if(Table1[i].locmap[com]==Table2[j].locmap[com])                       {
                        Rows obj;  
                        x=Table1[i].locmap[com];
                        bool flag=true,flag1=false;
                        std::deque<set_int> z,z1,t;
                        for(set_set_int::iterator it=Table1[i].Partition.begin();it!=Table1[i].Partition.end();it++)
                        { 
                            z.push_back(*it);
                        }
                        
                        for (set_set_int::iterator ite=Table2[j].Partition.begin();ite!=Table2[j].Partition.end();ite++)
                        {
                           z1.push_back(*ite);
                        }
                        
                         t=mPar(z,z1);
                        
                        for(deque<set_int>::iterator it=t.begin();it!=t.end();it++)
                        {
                            set_int tt=*it;
                            obj.Partition.insert(tt);
                        }
                         for(set_set_int::iterator it=obj.Partition.begin();it!=obj.Partition.end();it++)
                         {
                             set_int ite=*it;
                             for(set_int::iterator nit=ite.begin();nit!=ite.end();nit++)
                             {
                                 if(Table1[i].locmap[*nit]>0&&Table1[i].locmap[*nit]<=4)
                                 obj.locmap[*nit]=Table1[i].locmap[*nit];
                                 else obj.locmap[*nit]=Table2[j].locmap[*nit];
                             }
                         }
                         obj.cost=(Table1[i].cost*Table2[j].cost)/Dist[com-1][x-1];
                       //flag1=BadSt(obj,com);
                       
                      if(temp.size()>0) 
                      flag=Dcheck(temp,obj);
                    
                       if(flag&&!flag1)
                       {
                          
                         temp.push_back(obj);
                       }
           }
           }
            
        }

        return temp;
    }

tbl mTable1(tbl Table1,tbl Table2,set_int f)
    {
    set_int::iterator ii=f.begin();
    int com=*ii,com1=*(++ii);
       tbl temp;
       int x=1;
       
       for(int i=0;i<Table1.size();++i)
        {
           //cout<<Table1.size()<<" ";
           for(int j=0;j<Table2.size();j++)
             { 
              // cout<<x<<" ";x++;
                      if(Table1[i].locmap[com]==Table2[j].locmap[com]&&Table1[i].locmap[com1]==Table2[j].locmap[com1])                       
                      {
                        Rows obj;    
                        bool flag=true,flag1=false;
                        std::deque<set_int> z,z1,t;
                        for(set_set_int::iterator it=Table1[i].Partition.begin();it!=Table1[i].Partition.end();it++)
                        { 
                            z.push_back(*it);
                        }
                        
                        for (set_set_int::iterator ite=Table2[j].Partition.begin();ite!=Table2[j].Partition.end();ite++)
                        {
                           z1.push_back(*ite);
                        }
                        
                         t=mPar(z,z1);
                        
                        for(deque<set_int>::iterator it=t.begin();it!=t.end();it++)
                        {
                            set_int tt=*it;
                            obj.Partition.insert(tt);
                        }
                         for(set_set_int::iterator it=obj.Partition.begin();it!=obj.Partition.end();it++)
                         {
                             set_int ite=*it;
                             for(set_int::iterator nit=ite.begin();nit!=ite.end();nit++)
                             {
                                 if(Table1[i].locmap[*nit]>0&&Table1[i].locmap[*nit]<=4)
                                 obj.locmap[*nit]=Table1[i].locmap[*nit];
                                 else obj.locmap[*nit]=Table2[j].locmap[*nit];
                             }
                         }
                         double ii=Dist[com-1][Table1[i].locmap[com]-1],jj=Dist[com1-1][Table1[i].locmap[com1]-1];
                         obj.cost=(((Table1[i].cost*Table2[j].cost)/ii)/jj);
                       //flag1=BadSt(obj,com);
                       
                      if(temp.size()>0) 
                      flag=Dcheck(temp,obj);
                    
                       if(flag&&!flag1)
                       {
                          
                         temp.push_back(obj);
                       }
                      }
           }
            
        }

        return temp;
    }

tbl mTable3(tbl Table1,tbl Table2,int es)
    {
        tbl temp,ttt;
       for(int i=0;i<Table1.size();++i)
        {
                    for(int j=0;j<Table2.size();j++)
                    { 
                        Rows obj;
                        
                        bool flag=true,flag1=false;
                        std::deque<set_int> z,z1,t;
                        for(set_set_int::iterator it=Table1[i].Partition.begin();it!=Table1[i].Partition.end();it++)
                        { 
                            z.push_back(*it);
                        }
                        
                        for (set_set_int::iterator ite=Table2[j].Partition.begin();ite!=Table2[j].Partition.end();ite++)
                        {
                           z1.push_back(*ite);
                        }
                        
                         t=mPar(z,z1);
                        
                        for(deque<set_int>::iterator it=t.begin();it!=t.end();it++)
                        {
                            
                            
                            set_int tt=*it;
                            
                            //for(set_int::iterator qq=tt.begin();qq!=tt.end();qq++)
                            obj.Partition.insert(tt);
                            
                        }
                         
                      
                       for(set_set_int::iterator it=obj.Partition.begin();it!=obj.Partition.end();it++)
                         {
                           for(set_int::iterator iit=(*it).begin();iit!=(*it).end();iit++)
                           {
                            bool flag=false;
                            for(set_set_int::iterator t1i=Table1[i].Partition.begin();t1i!=Table1[i].Partition.end();t1i++)
                            {
                                for(set_int::iterator t11=(*t1i).begin();t11!=(*t1i).end();t11++)
                                {
                                   if(*iit==*t11)
                                   {
                                       obj.tnodeAttach[*it]=max(obj.tnodeAttach[*it],Table1[i].tnodeAttach[*t1i]); 
                                   flag=true;
                                   break;
                                   }
                                }
                            }
                                for(set_set_int::iterator st1i=Table2[j].Partition.begin();st1i!=Table2[j].Partition.end();st1i++)
                                { 
                                    for(set_int::iterator s11=(*st1i).begin();s11!=(*st1i).end();s11++)
                                    {
                                        if(*iit==*s11)
                                        {
                                            obj.tnodeAttach[*it]=max(obj.tnodeAttach[*it],Table2[j].tnodeAttach[*st1i]);
                                         flag=true;
                                         break;
                                        }
                                           
                                        }
                                    }
                                //if(flag)break;

                                }        
                         }
                         
                        
                        for(set_set_int::iterator sit=Table1[i].edgeset.begin();sit!=Table1[i].edgeset.end();sit++)
                        { 
                            obj.edgeset.insert(*sit);
                        }

                        for(set_set_int::iterator sit=Table2[j].edgeset.begin();sit!=Table2[j].edgeset.end();sit++)
                        {
                            obj.edgeset.insert(*sit);
                        }
                          obj.cost=0;
                          
                         for(set_set_int::iterator sit=obj.edgeset.begin();sit!=obj.edgeset.end();sit++)
                         {
                             int r=0;
                             
                           
                              r=findMnode(dbase1,*sit);
                             obj.cost+=dbase1[r-1][0].cost;
                         }
                         
                       flag1=BadSt(obj,es);
                    
                      if(temp.size()>0) 
                      flag=Dcheck(temp,obj);
                      
                      //cout<<endl;
                        if(flag&&!flag1)
                         temp.push_back(obj);
                    }
            
        }
        //pTnode(ttt);
        return temp;
    }

/*This Function will find neighbors nodes of a deleting */

int findMnode3(deque<tbl> db,int a,int b,int c)
{
    //cout<<a<<b<<c;
    int tContr=0,flag,M;
   for (deque<tbl>::iterator it=db.begin();it!=db.end();++it)
    {
        tbl Table=*it;
        flag=0;
        tContr++;
        set_int allNode;
        for(int i=0;i<Table.size();i++)
        { 
            for (set_set_int::iterator mit=Table[i].Partition.begin();mit!=Table[i].Partition.end();++mit)
            {
               set_int m=*mit; 
                for(set_int::iterator sit=m.begin();sit!=m.end();++sit)
                {
                    allNode.insert(*sit);
                    
                }
             }
        }
        if(allNode.find(a)!=allNode.end()&&allNode.find(b)!=allNode.end()&&allNode.find(c)!=allNode.end())
        {
            M=tContr;
            break;
        }
   }
    return M;
}

deque<q_int> findNodes(int es)
{
    deque<tbl> db=dbase;
   q_int T,T1;
   deque<q_int> r;
   std::deque<tbl>::iterator it;
   int j=0,flag=0,a;
   
   set_int s1;
   for (it=db.begin();it!=db.end();++it)
    {
        tbl Table=*it;
        
        j++;
        flag=0;
        for(int i=0;i<Table.size();i++)
        {
               
            for (set_set_int::iterator mit=Table[i].Partition.begin();mit!=Table[i].Partition.end();++mit)
            {
                set_int m=*mit;
                for(set_int::iterator sit=m.begin();sit!=m.end();++sit)
                {   if(flag==1&&*sit!=es)
                      {
                        s1.insert(*sit);
                        
                      }
                
                    if(*sit==es&&!flag)
                    {
                       
                       T.push(j);
                
                        flag=1;
                    }
                    
                }
             }
        }
   }
     
  r.push_back(T);
   
   return r;
}
q_int findNodes3(deque<tbl> db,int es)
{
   q_int T,T1;
   deque<q_int> r;
   std::deque<tbl>::iterator it;
   int j=0,flag=0,k=1,a,b;
   
   set_int s1;
   for (it=db.begin();it!=db.end();++it)
    {
        tbl Table=*it;
        
        j++;
        flag=0;
        for(int i=0;i<Table.size();i++)
        {
               
            for (set_set_int::iterator mit=Table[i].Partition.begin();mit!=Table[i].Partition.end();++mit)
            {
                set_int m=*mit;
                for(set_int::iterator sit=m.begin();sit!=m.end();++sit)
                {   if(flag==1&&*sit!=es)
                      {
                        s1.insert(*sit);
                        
                      }
                
                    if(*sit==es&&!flag)
                    {
                       
                       T.push(j);
                
                        flag=1;
                    }
                    
                }
                
             }
        }
   }
   int aa[s1.size()+1],i=0;
 for(set_int::iterator sit=s1.begin();sit!=s1.end();sit++)         
 { aa[i]=*sit;i++;
    
 }         
   
         int a1=findMnode3(db,aa[0],aa[1],aa[2]);
           T.push(a1);
   //r.push_back(T);
  // r.push_back(T1);
   return T;
}
void pAllTable(std::deque<tbl> db)
{
  
    for (deque<tbl>::iterator it=db.begin();it!=db.end();++it)
    {
        tbl Table=*it;
          double c=0;
        for(int i=0;i<Table.size();i++)
        {
            if(i%2==0)cout<<endl;
             for (set_set_int::iterator it=Table[i].Partition.begin();it!=Table[i].Partition.end();it++)
            {
                set_int T=*it;
                cout<<"{";
                for(set_int::iterator t=T.begin();t!=T.end();t++)
                {
                    cout<<*t<<" ";
                }
                cout<<"}";
            }
             cout<<"   ";
           for (std::map<int,int>::iterator mit=Table[i].locmap.begin();mit!=Table[i].locmap.end();++mit)
                {
                        cout<<mit->second<<" ";
                }
             cout<<Table[i].cost;
             if(Table[i].Partition.size()==1)c+=Table[i].cost;
                printf("\n");
        }
        printf("\n");
        cout<<"total cost="<<c;
      }
  
}


double EuclDist(double x1,double y1,double x2,double y2)
{
    
    double temp;
    temp= sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
    //cout<<x1<<" "<<y1<<" "<<x2<<" "<<y2<<" "<<temp;
    return temp;
}
void Preprocess()
{
    int i,nx,ny;
    std::ifstream input("input7.txt");
    std::string line;
     
    freopen("output.txt","w",stdout);
    printf("Elimination sequence :=");
    getline(input,line);
    istringstream is(line );
    int n;
    while( is >> n ) 
    {
       ElSeq.push(n);
        cout<<"   "<<n<<"  ";
    }
    
    
    printf("\n Transmission Range ");
    getline(input,line);
    istringstream is1(line);
    is1>>Tx;
    cout<<Tx;
    printf("\n Node#  PoN IG(X     Y)   EG(X   Y)    NX   NY\n");
    for(int k=0;k<7;k++)
    {
        q_int a,b;
        q_double m;
        getline(input,line);
        istringstream is2(line );
        double n;
        int t;
        
        
        while(is2 >> n) 
        {
            a.push(n);
            cout<<"   "<<n<<"  ";
            m.push(n);
             if(t>=6)Dist[k][t-6]=n;
        }
        for(int i=0;i<4;i++)
        {Dist[k][i]=m.back();
        m.pop();
        
        }
        b=a;
        ny=b.back();
        b.pop();
        nx=b.back();
        cout<<endl;
        posdb.push_back(a);
     }
 
   
    while( std::getline( input, line ))
    {
        
        
        tbl Table;
        int a[4],k=0;
        set_int temp,temp1,temp2;
        istringstream is4( line );
        is4 >> a[0]>>a[1]; 
        temp.insert(a[0]);
        temp.insert(a[1]);
        temp1.insert(a[0]);
        temp2.insert(a[1]);
        
        
        q_int a1,b;
        a1=posdb[a[0]-1];
    
    b=posdb[a[1]-1];
    
    int i=0,p[a1.size()+1],q[b.size()+1];
    while(!a1.empty())
    {
        p[i]=a1.front();
        a1.pop();
        i++;
    }
    i=0;
    while(!b.empty())
    {
      q[i]=b.front();
      b.pop();
      i++;
     }
       
    double x1,y1,x2,y2,dist;
    int Cntr=1,Cntr1;
    for(int j=p[3];j<p[5];j++)
    {  
          for(int k=p[2];k<p[4];k++)
          {
              
                  
                  y1=double(j+j+1)/2;
                  x1=double(k+k+1)/2;
              
              
              
            Cntr1=1;
            for(int j1=q[3];j1<q[5];j1++)
             { 
                 for(int k1=q[2];k1<q[4];k1++)
                 {
                     
                         Rows obj,obj1;
//                          q_int n,m,p;
                         y2=double(j1+j1+1)/2;
                         x2=double(k1+k1+1)/2;
                         dist=EuclDist(x1,y1,x2,y2);
                     
                      if(dist<=Tx)
                      {
                          
                         
//                          
//                          n.push(Cntr);
//                          n.push(Cntr1);
//                          m.push(Cntr);
//                          p.push(Cntr1);
//                          
                          
                          obj.Partition.insert(temp);
                          obj.locmap[a[0]]=Cntr;                         
                          obj.locmap[a[1]]=Cntr1; 
                         obj.cost=Dist[p[0]-1][Cntr-1]*Dist[q[0]-1][Cntr1-1];
                          Table.push_back(obj);

                          obj1.Partition.insert(temp1);
                          obj1.Partition.insert(temp2);
                          obj1.locmap[a[0]]=Cntr;
                          obj1.locmap[a[1]]=Cntr1;
                          obj1.cost=0;
                         Table.push_back(obj1);
                        
                      }
                      else
                      {
                          obj1.Partition.insert(temp1);
                          obj1.Partition.insert(temp2);
                          obj1.locmap[a[0]]=Cntr;
                          obj1.locmap[a[1]]=Cntr1;
                          obj1.cost=Dist[p[0]-1][Cntr-1]*Dist[q[0]-1][Cntr1-1];
                         Table.push_back(obj1);
                      }
                    
                     Cntr1++;

                 }
             }
            Cntr++;
           
          }
     }
        
       
        
        dbase.push_back(Table);
        
    }
 }






set_int searchP(tbl Table1,tbl Table2)
{
    set_int r,temp,Rval;
    for(set_set_int::iterator iit=Table1[0].Partition.begin();iit!=Table1[0].Partition.end();iit++)
    {
        set_int p=*iit;
    for(set_int::iterator it=p.begin();it!=p.end();it++)
    {
        r.insert(*it);
    }
    }
    temp=r;
   for(set_set_int::iterator iit=Table2[0].Partition.begin();iit!=Table2[0].Partition.end();iit++)
   {
       set_int q=*iit;
    for(set_int::iterator it=q.begin();it!=q.end();it++)
    {
        temp.insert(*it);
        if(temp.size()==r.size())Rval.insert(*it);
        else temp.erase(*it);
    }
   }
    return Rval;
}
/*This Function will merge two Table Partition*/
  tbl mTab_final(tbl Table1,tbl Table2,int es)
    {
       tbl temp;
       int x=1;
        set_int com=searchP(Table1,Table2);
       for(int i=0;i<Table1.size();++i)
        {
           //cout<<Table1.size()<<" ";
           for(int j=0;j<Table2.size();j++)
             { 
              // cout<<x<<" ";x++;
               bool flg=false;
               for(set_int::iterator it=com.begin();it!=com.end();it++)
               {
                   if (Table1[i].locmap[*it]!=Table2[j].locmap[*it])flg=true;
               }
                       if(!flg)     
                       {
                        Rows obj;    
                        bool flag=true,flag1=false;
                        std::deque<set_int> z,z1,t;
                        for(set_set_int::iterator it=Table1[i].Partition.begin();it!=Table1[i].Partition.end();it++)
                        { 
                            z.push_back(*it);
                        }
                        
                        for (set_set_int::iterator ite=Table2[j].Partition.begin();ite!=Table2[j].Partition.end();ite++)
                        {
                           z1.push_back(*ite);
                        }
                        
                         t=mPar(z,z1);
                        
                        for(deque<set_int>::iterator it=t.begin();it!=t.end();it++)
                        {
                            set_int tt=*it;
                            obj.Partition.insert(tt);
                        }
                         for(set_set_int::iterator it=obj.Partition.begin();it!=obj.Partition.end();it++)
                         {
                             set_int ite=*it;
                             for(set_int::iterator nit=ite.begin();nit!=ite.end();nit++)
                             {
                                 if(Table1[i].locmap[*nit]>0&&Table1[i].locmap[*nit]<=4)
                                 obj.locmap[*nit]=Table1[i].locmap[*nit];
                                 else obj.locmap[*nit]=Table2[j].locmap[*nit];
                             }
                         }
                         obj.cost=(Table1[i].cost*Table2[j].cost)/(Val*Val*Val);
                       flag1=BadSt(obj,es);
                       
                      if(temp.size()>0) 
                      flag=Dcheck(temp,obj);
                    
                       if(flag&&!flag1)
                       {
                          
                         temp.push_back(obj);
                       }
           }
           }
            
        }

        return temp;
    }            
tbl mTab(tbl Table1,tbl Table2)
    {
       tbl temp;
       //need to change from here
        set_int com=searchP(Table1,Table2);
       for(int i=0;i<Table1.size();++i)
        {
           //cout<<Table1.size()<<" ";
           for(int j=0;j<Table2.size();j++)
             { 
              // cout<<x<<" ";x++;
               bool flg=false;
               for(set_int::iterator it=com.begin();it!=com.end();it++)
               {
                   int x=*it;
                   if (Table1[i].locmap[x]!=Table2[j].locmap[x])flg=true;
               }
                       if(!flg)     
                       {
                        Rows obj;    
                        bool flag=true,flag1=false;
                        std::deque<set_int> z,z1,t;
                        for(set_set_int::iterator it=Table1[i].Partition.begin();it!=Table1[i].Partition.end();it++)
                        { 
                            z.push_back(*it);
                        }
                        
                        for (set_set_int::iterator ite=Table2[j].Partition.begin();ite!=Table2[j].Partition.end();ite++)
                        {
                           z1.push_back(*ite);
                        }
                        
                         t=mPar(z,z1);
                        
                        for(deque<set_int>::iterator it=t.begin();it!=t.end();it++)
                        {
                            set_int tt=*it;
                            obj.Partition.insert(tt);
                        }
                         for(set_set_int::iterator it=obj.Partition.begin();it!=obj.Partition.end();it++)
                         {
                             set_int ite=*it;
                             for(set_int::iterator nit=ite.begin();nit!=ite.end();nit++)
                             {
                                 if(Table1[i].locmap[*nit]>0&&Table1[i].locmap[*nit]<=4)
                                 obj.locmap[*nit]=Table1[i].locmap[*nit];
                                 else obj.locmap[*nit]=Table2[j].locmap[*nit];
                             }
                         }
                         int t1[3],i1=0;
                        for(set_int::iterator it=com.begin();it!=com.end();it++)
                         {
                          t1[i1]=*it;
                          i1++;
                        }
                         
                         double ii=Dist[t1[0]-1][Table1[i].locmap[t1[0]]-1],jj=Dist[t1[1]-1][Table1[i].locmap[t1[1]]-1];
                         obj.cost=(Table1[i].cost*Table2[j].cost)/(ii*jj);
                      
                      if(temp.size()>0) 
                      flag=Dcheck(temp,obj);
                    
                       if(flag&&!flag1)
                       {
                          
                         temp.push_back(obj);
                       }
           }
           }
            
        }

        return temp;
    }
tbl mTab1(tbl Table1,tbl Table2)
    {
       tbl temp;
       int x=1;
        set_int com=searchP(Table1,Table2);
       for(int i=0;i<Table1.size();++i)
        {
           //cout<<Table1.size()<<" ";
           for(int j=0;j<Table2.size();j++)
             { 
              // cout<<x<<" ";x++;
               bool flg=false;
               for(set_int::iterator it=com.begin();it!=com.end();it++)
               {
                   int x=*it;
                   if (Table1[i].locmap[x]!=Table2[j].locmap[x])flg=true;
               }
                       if(!flg)     
                       {
                        Rows obj;    
                        bool flag=true,flag1=false;
                        std::deque<set_int> z,z1,t;
                        for(set_set_int::iterator it=Table1[i].Partition.begin();it!=Table1[i].Partition.end();it++)
                        { 
                            z.push_back(*it);
                        }
                        
                        for (set_set_int::iterator ite=Table2[j].Partition.begin();ite!=Table2[j].Partition.end();ite++)
                        {
                           z1.push_back(*ite);
                        }
                        
                         t=mPar(z,z1);
                        
                        for(deque<set_int>::iterator it=t.begin();it!=t.end();it++)
                        {
                            set_int tt=*it;
                            obj.Partition.insert(tt);
                        }
                         for(set_set_int::iterator it=obj.Partition.begin();it!=obj.Partition.end();it++)
                         {
                             set_int ite=*it;
                             for(set_int::iterator nit=ite.begin();nit!=ite.end();nit++)
                             {
                                 if(Table1[i].locmap[*nit]>0&&Table1[i].locmap[*nit]<=4)
                                 obj.locmap[*nit]=Table1[i].locmap[*nit];
                                 else obj.locmap[*nit]=Table2[j].locmap[*nit];
                             }
                         }
                         obj.cost=(Table1[i].cost*Table2[j].cost)/(Val*Val*Val);
                       //flag1=BadSt(obj,com);
                       
                      if(temp.size()>0) 
                      flag=Dcheck(temp,obj);
                    
                       if(flag&&!flag1)
                       {
                          
                         temp.push_back(obj);
                       }
           }
           }
            
        }

        return temp;
    }
int CreateTable()
{

  // int es;
   
   Preprocess();
  

   dbase1=dbase;
   pAllTable(dbase1);
  cout<<"End";
   
   q_int els=ElSeq;
   
    tbl Temp2;
    while(!els.empty())
    {
       int e=els.front();
       //cout<<e;
       els.pop();
        int t1,t2,t3;
        deque<q_int> r;
        q_int T,tt;
        
        r=findNodes(e);
        for(deque<q_int>::iterator it=r.begin();it!=r.end();it++)
        {
            T=*it;
         }
        tt=T;
        int a[T.size()+2],ii=1;
       
        
        for(;!tt.empty();)
        {
            a[ii]=tt.front();
            tt.pop();
            ii++;
        }
       
        for(int i=1;i<=T.size();i++)
        {
            for(int j=i+1;j<=T.size();j++)
            {
                t1=a[i];t2=a[j]; 
                
           
           Temp2=mTable(dbase[t1-1],dbase[t2-1],e);
           //pTnode(Temp2);
           cout<<endl;
           set_int ss;
          for( set_set_int::iterator it= Temp2[0].Partition.begin();it!=Temp2[0].Partition.end();it++)
          {
           set_int sit=*it;
           for(set_int::iterator ssit=sit.begin();ssit!=sit.end();ssit++)
           {
               ss.insert(*ssit);
           }
          }
           ss.erase(ss.find(e));
           
           t3=findMnode(dbase,ss);
           
           tbl tem=mTable1(Temp2,dbase[t3-1],ss);
           pTnode(tem);
           
            tdb.push_back(tem);
        
            } 
        }
        
        for(int i=T.size();i>=1;i--)
        {
            for(int nn=a[i]-1;nn<dbase.size()-1;nn++)
                dbase[nn]=dbase[nn+1];
            dbase.pop_back();
        }
    }
    dbase=tdb;
    //ElSeq=els;
return 0;
}
void threeTree()
{
    deque<q_int> r;
    deque<tbl> tempT;
    q_int T,T1,tt;
    tbl temp2;
    int es;
    CreateTable();
    cout<<"dbase3t\n";
    pAllTable(dbase);
     cout<<"dbase 3tEnd\n";
    tempT=dbase;
    T=ElSeq;
    
    while(T.size()>3) 
    {
        es=T.front();
        T1=findNodes3(dbase ,es);
        T.pop();
        tt=T1;
        int a[T1.size()+2],ii=1;
       
        
        for(;!tt.empty();)
        {
            a[ii]=tt.front()-1;
          
            tt.pop();
            ii++;
        }
       
        temp2=mTab(dbase[a[1]],dbase[a[2]]);
        //pTnode(temp2);cout<<"Xend"<<endl;
        temp2=mTab1(dbase[a[3]],temp2);
        //pTnode(temp2);cout<<endl;
        dbase[a[4]]=mTab_final(temp2,dbase[a[4]],es);
        pTnode(dbase[a[4]]);
        for(int i=T1.size()-1;i>=1;i--)
        {
            for(int nn=a[i];nn<dbase.size()-1;nn++)
                dbase[nn]=dbase[nn+1];
            dbase.pop_back();
        }
       
   }
    cout<<"Final:db\n";
     pAllTable(dbase);
      cout<<"Final:db End\n";
     dbase=tempT;
}
int main()
{
    threeTree();
}